

float3 inColour = SceneTextureLookup(ViewportUVToSceneTextureUV(UV,PPI_PostProcessInput0), PPI_PostProcessInput0, false).rgb;

float2 offsets[8] =
{
  {-1,  1}, //top left  
  {1,   1}, //top right
  {-1, -1}, //bottom left  
  {1,  -1}, //bottom right
  
  {0,   1}, //right  
  {0,  -1}, //left
  {1,   0}, //top
  {-1,  0}, //bottom
};


//TODO: can we make this editable from the material graph? it doesn't support arrays...
float4 outlineColours[4] = 
{
    {250.0, 0.6, 0.0, 0.0},                     //Red
    {251.0, 0.17, 0.52, 1.0},                   //Tealy Blue
    {252.0, 1.0, 0.0, 0.33},                  //purple
    {253.0, 0.07, 1.0, 0.0},                   //green
};


float maskBorder = false;

int totalMask = 0;
int numValidMasks = 0;

float currPixelDepth = SceneTextureLookup(ViewportUVToSceneTextureUV(UV,PPI_SceneDepth), PPI_SceneDepth, false).r;
float linearDepth = ConvertFromDeviceZ(currPixelDepth);

float scaledFilterSize = max((FilterSize * linearDepth), 2.0);
float2 offsetSize = TexCoordSize * scaledFilterSize;

int currPixelMask = SceneTextureLookup(ViewportUVToSceneTextureUV(UV, PPI_CustomStencil), PPI_CustomStencil, false).r;


//we should outline if we detect change in mask OR change in depth
float lowestDepth = 10000;
float highestDepth = 0;
for(int i = 0; i < 8; i++)
{
    float2 UVsToSample = UV + (offsetSize * offsets[i]);
    int mask = SceneTextureLookup(ViewportUVToSceneTextureUV(UVsToSample, PPI_CustomStencil), PPI_CustomStencil, false).r;
    totalMask += mask;

    
    if(mask > 0)
    {
        numValidMasks++;
        float depth = SceneTextureLookup(ViewportUVToSceneTextureUV(UVsToSample, PPI_SceneDepth), PPI_SceneDepth, false).r;
    
        lowestDepth = min(lowestDepth, depth);
        highestDepth = max(highestDepth, depth);

        if(mask != currPixelMask)
        {
            maskBorder = true;
        }
    }
}

float displayOutline = 0.0;

// float sameMask = totalMask > 0 && currPixelMask > 0;
// float depthVariation = abs(highestDepth - lowestDepth) > 15.0;
// float closerToBack = abs(currPixelDepth - lowestDepth) > abs(currPixelDepth - highestDepth);





maskBorder = maskBorder;// || (sameMask && depthVariation && closerToBack);

if(     totalMask > 0           //must have some nearby masks
    &&  maskBorder)     //must be a different mask to ours OR depth difference is sufficient
{
    displayOutline = 1.0;

    //Attempt to use a fresnel to get a gradient-based outline.
    //Result is ugly because of the UVs we sample at, they aren't smoothly along the edge of the surface.
    //float3 N = normalize(SceneTextureLookup(ViewportUVToSceneTextureUV(maskUVs, PPI_WorldNormal), PPI_WorldNormal, false).rgb);       // pixel normal
    // float3 V = normalize(CameraVector);      // direction from pixel to camera
    // float fresnel = pow(1.0 - saturate(dot(N, V)), FresnelExponent);
    // fresnel = fresnel + BaseReflectFraction;
    // displayOutline = fresnel;
}


float3 outlineColour = float3(0.0, 0.0, 0.0);
float averageMask = float(totalMask) / float(numValidMasks);
int closestColour = 0;
float closestWeight = 1.0;

for(int i = 0; i < 4; i++)
{
    float diff = abs(averageMask - outlineColours[i].x);

    if(diff < closestWeight)
    {
        closestColour = i;
        closestWeight = diff;
    }
}
outlineColour = outlineColours[closestColour].yzw;

float3 outColour = lerp(inColour, outlineColour, displayOutline);


return outColour;