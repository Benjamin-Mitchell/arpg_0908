

float3 inColour = SceneTextureLookup(ViewportUVToSceneTextureUV(UV,PPI_PostProcessInput0), PPI_PostProcessInput0, false).rgb;

float2 offsets[8] =
{
  {-1,  1}, //top left  
  {1,   1}, //top right
  {-1, -1}, //bottom left  
  {1,  -1}, //bottom right
  
  {0,   1}, //right  
  {0,  -1}, //left
  {1,   0}, //top
  {-1,  0}, //bottom
};


//TODO: can we make this editable from the material graph? it doesn't support arrays...
float4 outlineColours[4] = 
{
    {250.0, 0.6, 0.0, 0.0},
    {251.0, 0.17, 0.52, 1.0},
    {252.0, 0.28, 0.0, 0.098},
    {253.0, 0.07, 0.28, 0.0},
};


float maskBorder = false;

int totalMask = 0;
int numValidMasks = 0;

//float currPixelCustomDepth = SceneTextureLookup(ViewportUVToSceneTextureUV(UV,PPI_CustomDepth), PPI_CustomDepth, false).r;
float currPixelDepth = SceneTextureLookup(ViewportUVToSceneTextureUV(UV,PPI_SceneDepth), PPI_SceneDepth, false).r;
float linearDepth = ConvertFromDeviceZ(currPixelDepth);

float scaledFilterSize = max((FilterSize * linearDepth), 2.0);
float2 offsetSize = TexCoordSize * scaledFilterSize;

int currPixelMask = SceneTextureLookup(ViewportUVToSceneTextureUV(UV, PPI_CustomStencil), PPI_CustomStencil, false).r;


//we should outline if we detect change in mask OR change in depth
float lowestDepth = 10000;
float highestDepth = 0;
for(int i = 0; i < 8; i++)
{
    int mask = SceneTextureLookup(ViewportUVToSceneTextureUV(UV + (offsetSize * offsets[i]), PPI_CustomStencil), PPI_CustomStencil, false).r;
    totalMask += mask;

    
    if(mask > 0)
    {
        numValidMasks++;
        float depth = SceneTextureLookup(ViewportUVToSceneTextureUV(UV + (offsetSize * offsets[i]), PPI_SceneDepth), PPI_SceneDepth, false).r;
    
        lowestDepth = min(lowestDepth, depth);
        highestDepth = max(highestDepth, depth);

        if(mask != currPixelMask)
            maskBorder = true;
    }
}

float displayOutline = 0.0;

// float sameMask = totalMask > 0 && currPixelMask > 0;
// float depthVariation = abs(highestDepth - lowestDepth) > 15.0;
// float closerToBack = abs(currPixelDepth - lowestDepth) > abs(currPixelDepth - highestDepth);

maskBorder = maskBorder;// || (sameMask && depthVariation && closerToBack);

if(     totalMask > 0           //must have some nearby masks
    &&  maskBorder)     //must be a different mask to ours OR depth difference is sufficient
{
    displayOutline = 1.0;
}


float3 outlineColour = float3(0.0, 0.0, 0.0);
float averageMask = float(totalMask) / float(numValidMasks);
int closestColour = 0;
float closestWeight = 1.0;

for(int i = 0; i < 4; i++)
{
    float diff = abs(averageMask - outlineColours[i].x);

    if(diff < closestWeight)
    {
        closestColour = i;
        closestWeight = diff;
    }
}
outlineColour = outlineColours[closestColour].yzw;

float3 outColour = lerp(inColour, outlineColour, displayOutline);

return outColour;